// SPDX-FileCopyrightText: 2013 tpu
// SPDX-FileCopyrightText: 2015 Hykem <hykem@hotmail.com>
// SPDX-License-Identifier: GPL-3.0-only

#include "eboot.h"

TAG_KEY key_list[] = {
	{0x8004fd03,{0xf4,0xae,0xf4,0xe1,0x86,0xdd,0xd2,0x9c,0x7c,0xc5,0x42,0xa6,0x95,0xa0,0x83,0x88},0x5d,2}, // 2.71 new
	{0xd91605f0,{0xb8,0x8c,0x45,0x8b,0xb6,0xe7,0x6e,0xb8,0x51,0x59,0xa6,0x53,0x7c,0x5e,0x86,0x31},0x5d,2}, // 2.80
	{0xd91606f0,{0xed,0x10,0xe0,0x36,0xc4,0xfe,0x83,0xf3,0x75,0x70,0x5e,0xf6,0xa4,0x40,0x05,0xf7},0x5d,2}, // 3.00
	{0xd91608f0,{0x5c,0x77,0x0c,0xbb,0xb4,0xc2,0x4f,0xa2,0x7e,0x3b,0x4e,0xb4,0xb4,0xc8,0x70,0xaf},0x5d,2}, // 3.10
	{0xd91609f0,{0xd0,0x36,0x12,0x75,0x80,0x56,0x20,0x43,0xc4,0x30,0x94,0x3e,0x1c,0x75,0xd1,0xbf},0x5d,2}, // 5.00
	{0xd9160af0,{0x10,0xa9,0xac,0x16,0xae,0x19,0xc0,0x7e,0x3b,0x60,0x77,0x86,0x01,0x6f,0xf2,0x63},0x5d,2}, // 5.05
	{0xd9160bf0,{0x83,0x83,0xf1,0x37,0x53,0xd0,0xbe,0xfc,0x8d,0xa7,0x32,0x52,0x46,0x0a,0xc2,0xc2},0x5d,2}, // 5.55
	{0xd91610f0,{0x89,0x07,0x73,0xb4,0x09,0x08,0x3f,0x54,0x31,0x87,0x00,0xf3,0x35,0x14,0x55,0xcc},0x5d,2}, // 3.60
	{0xd91611f0,{0x61,0xb0,0xc0,0x58,0x71,0x57,0xd9,0xfa,0x74,0x67,0x0e,0x5c,0x7e,0x6e,0x95,0xb9},0x5d,2}, // 6.00 - 6.10
	{0xd91612f0,{0x9e,0x20,0xe1,0xcd,0xd7,0x88,0xde,0xc0,0x31,0x9b,0x10,0xaf,0xc5,0xb8,0x73,0x23},0x5d,2}, // 6.20
	{0xd91613f0,{0xeb,0xff,0x40,0xd8,0xb4,0x1a,0xe1,0x66,0x91,0x3b,0x8f,0x64,0xb6,0xfc,0xb7,0x12},0x5d,2},
	{0xd91614f0,{0xfd,0xf7,0xb7,0x3c,0x9f,0xd1,0x33,0x95,0x11,0xb8,0xb5,0xbb,0x54,0x23,0x73,0x85},0x5d,2},
	{0xd91615f0,{0xc8,0x03,0xe3,0x44,0x50,0xf1,0xe7,0x2a,0x6a,0x0d,0xc3,0x61,0xb6,0x8e,0x5f,0x51},0x5d,2},
	{0xd91616f0,{0x53,0x03,0xb8,0x6a,0x10,0x19,0x98,0x49,0x1c,0xaf,0x30,0xe4,0x25,0x1b,0x6b,0x28},0x5d,2},
	{0xd91617f0,{0x02,0xfa,0x48,0x73,0x75,0xaf,0xae,0x0a,0x67,0x89,0x2b,0x95,0x4b,0x09,0x87,0xa3},0x5d,2},
	{0xd91618f0,{0x96,0x96,0x7c,0xc3,0xf7,0x12,0xda,0x62,0x1b,0xf6,0x9a,0x9a,0x44,0x44,0xbc,0x48},0x5d,2},
	{0xd91619f0,{0xe0,0x32,0xa7,0x08,0x6b,0x2b,0x29,0x2c,0xd1,0x4d,0x5b,0xee,0xa8,0xc8,0xb4,0xe9},0x5d,2},
	{0xd9161af0,{0x27,0xe5,0xa7,0x49,0x52,0xe1,0x94,0x67,0x35,0x66,0x91,0x0c,0xe8,0x9a,0x25,0x24},0x5d,2},
	{0xd9161ef0,{0x5b,0x4a,0xd2,0xf6,0x49,0xd4,0xeb,0x0d,0xc0,0x0f,0xcb,0xa8,0x15,0x2f,0x55,0x08},0x5d,2}, // 5.00 psp-3000
	{0xd91620f0,{0x52,0x1c,0xb4,0x5f,0x40,0x3b,0x9a,0xdd,0xac,0xfc,0xea,0x92,0xfd,0xdd,0xf5,0x90},0x5d,2},
	{0xd91621f0,{0xd1,0x91,0x2e,0xa6,0x21,0x14,0x29,0x62,0xf6,0xed,0xae,0xcb,0xdd,0xa3,0xba,0xfe},0x5d,2},
	{0xd91622f0,{0x59,0x5d,0x78,0x4d,0x21,0xb2,0x01,0x17,0x6c,0x9a,0xb5,0x1b,0xda,0xb7,0xf9,0xe6},0x5d,2},
	{0xd91623f0,{0xaa,0x45,0xeb,0x4f,0x62,0xfb,0xd1,0x0d,0x71,0xd5,0x62,0xd2,0xf5,0xbf,0xa5,0x2f},0x5d,2},
	{0xd91624f0,{0x61,0xb7,0x26,0xaf,0x8b,0xf1,0x41,0x58,0x83,0x6a,0xc4,0x92,0x12,0xcb,0xb1,0xe9},0x5d,2},
	{0xd91628f0,{0x49,0xa4,0xfc,0x66,0xdc,0xe7,0x62,0x21,0xdb,0x18,0xa7,0x50,0xd6,0xa8,0xc1,0xb6},0x5d,2}, // 5.70 pspgo
	{0xd91680f0,{0x2c,0x22,0x9b,0x12,0x36,0x74,0x11,0x67,0x49,0xd1,0xd1,0x88,0x92,0xf6,0xa1,0xd8},0x5d,6}, // 6.30
	{0xd91681f0,{0x52,0xb6,0x36,0x6c,0x8c,0x46,0x7f,0x7a,0xcc,0x11,0x62,0x99,0xc1,0x99,0xbe,0x98},0x5d,6}, // 6.36
	{0xd91690f0,{0x42,0x61,0xe2,0x57,0x94,0x49,0x42,0xb5,0xaa,0x6d,0x0d,0x08,0x3d,0x24,0xf7,0x4b},0x5d,2}, // 6.60
};

static u8 test_k140[16] = {
	0x35, 0xfe, 0x4c, 0x96, 0x00, 0xb2, 0xf6, 0x7e, 0xf5, 0x83, 0xa6, 0x79, 0x1f, 0xa0, 0xe8, 0x86,
};
static u8 test_kirk1[32] = {
	0xca, 0x03, 0x84, 0xb1, 0xd9, 0x63, 0x47, 0x92, 0xce, 0xc7, 0x01, 0x23, 0x43, 0x72, 0x68, 0xac,
	0x77, 0xea, 0xec, 0xba, 0x6d, 0xaa, 0x97, 0xdf, 0xfe, 0x91, 0xb9, 0x39, 0x70, 0x99, 0x8b, 0x3a,
};

TAG_KEY *tkey;
u8 tag_key[0x100];
char *strtable;
int e_shnum;
Elf32_Shdr *section;

/*
	PSP header building functions.
*/
Elf32_Shdr *find_section(char *name)
{
	int i;

	for (i = 0; i < e_shnum; i++) {
		if (strcmp(name, strtable+section[i].sh_name) == 0)
			return &section[i];
	}

	return NULL;
}

void fix_reloc7(u8 *ebuf)
{
	Elf32_Rel *rel;
	int i, count;
	u32 j;

	count = 0;
	for (i = 0; i < e_shnum; i++) 
	{
		if (section[i].sh_type == 0x700000A0) 
		{
			rel = (Elf32_Rel*)(ebuf+section[i].sh_offset);
			for (j = 0; j < section[i].sh_size / sizeof(Elf32_Rel); j++) 
			{
				if ((rel[j].r_info & 0xFF) == 7) {
					rel[j].r_info = 0;
					count++;
				}
			}
		}
	}
}

void build_psp_header(PSP_Header2 *psph, u8 *ebuf, int esize)
{
	Elf32_Ehdr *elf;
	Elf32_Shdr *sh;
	Elf32_Phdr *ph;
	SceModuleInfo *modinfo;
	int i, j, shtab_size;

	elf = (Elf32_Ehdr*)(ebuf);

	section = (Elf32_Shdr *)(ebuf+elf->e_shoff);
	e_shnum = elf->e_shnum;

	shtab_size = e_shnum*elf->e_shentsize;
	if (elf->e_shoff + shtab_size > (u32)esize) {
		e_shnum = 0;
	} else {
		strtable = (char*)(ebuf + section[elf->e_shstrndx].sh_offset);
		fix_reloc7(ebuf);
	}

	memset(psph, 0, sizeof(PSP_Header2));

	psph->signature = 0x5053507E;
	psph->mod_attribute = 0;
	psph->comp_attribute = 0;
	psph->module_ver_lo = 1;
	psph->module_ver_hi = 1;
	psph->mod_version = 1;
	psph->devkit_version = 0x06020010;
	psph->decrypt_mode = 9;
	psph->overlap_size = 0;

	psph->comp_size = esize;
	psph->_80 = 0x80;

	psph->boot_entry = elf->e_entry;
	psph->elf_size = esize;
	psph->psp_size = ((esize + 15) & 0xfffffff0) + 0x150;

	ph = (Elf32_Phdr*)(ebuf + elf->e_phoff);
	sh = find_section(".rodata.sceModuleInfo");
	
	if (sh) {
		psph->modinfo_offset = sh->sh_offset;
		modinfo = (SceModuleInfo*)(ebuf + sh->sh_offset);
	} else {
		psph->modinfo_offset = ph[0].p_paddr;
		modinfo = (SceModuleInfo*)(ebuf+ph[0].p_paddr);
	}

	strcpy(psph->modname, modinfo->modname);

	j = 0;
	for (i = 0; i < elf->e_phnum; i++)
	{
		if (ph[i].p_type == PT_LOAD) {
			if (j > 3) {
				fprintf(stderr, "ERROR: Too many EBOOT PH segments!\n");
				continue;
			}
			psph->seg_align[j]   = ph[i].p_align;
			psph->seg_address[j] = ph[i].p_vaddr;
			psph->seg_size[j]    = ph[i].p_memsz;
			psph->bss_size = ph[i].p_memsz-ph[i].p_filesz;
			j++;
		}
	}

	psph->nsegments = j;
}

/*
	PSP tag generating function.
*/
void build_tag_key(TAG_KEY *tk)
{
	int i;
	u32 *k7 = (u32*)tag_key;

	for (i = 0; i < 9; i++) {
		memcpy(tag_key + 0x14 + (i * 16), tk->key, 0x10);
		tag_key[0x14 + (i * 16)] = i;
	}

	k7[0] = KIRK_MODE_DECRYPT_CBC;
	k7[1] = 0;
	k7[2] = 0;
	k7[3] = tk->code;
	k7[4] = 0x90;

	kirk_CMD7(tag_key, tag_key, 0x90 + 0x14);
}

/*
	PSP KIRK1 forging function.
*/
void build_psp_kirk1(u8 *kbuf, u8 *pbuf, int esize)
{
	KIRK_CMD1_HEADER *k1 = (KIRK_CMD1_HEADER *)kbuf;
	int i;

	memcpy(kbuf, test_kirk1, 32);

	k1->mode = KIRK_MODE_CMD1;
	k1->data_size = esize;
	k1->data_offset = 0x80;
	
	if (tkey->type == 6)
		k1->ecdsa_hash = 1;

	memcpy(kbuf + 0x90, pbuf, 0x80);

	if (esize % 16) {
		for (i = 0; i < (16 - (esize % 16)); i++) {
			kbuf[0x110 + esize + i] = 0xFF - i * 0x11;
		}
	}
	
	kirk_CMD0(kbuf, kbuf, esize, 0);
}

/*
	PSP SHA1 generating function.
*/
void build_psp_SHA1(u8 *ebuf, u8 *pbuf)
{
	u8 tmp[0x150];
	u32 *k4 = (u32*)tmp;
	int i;

	memset(tmp, 0, 0x150);

	for (i = 0; i < 0x40; i++) {
		tmp[0x14 + i] = ebuf[0x40 + i] ^ tag_key[0x50 + i];
	}
	memcpy(tmp + 0xd0, pbuf, 0x80);

	k4[0] = KIRK_MODE_ENCRYPT_CBC;
	k4[1] = 0;
	k4[2] = 0;
	k4[3] = tkey->code;
	k4[4] = 0x40;
	kirk_CMD4(tmp + 0x80 - 0x14, tmp, 0x40 + 0x14);

	for (i = 0; i < 0x40; i++) {
		tmp[0x80 + i] ^=  tag_key[0x10 + i];
	}

	memcpy(tmp + 0xd0, pbuf, 0x80);
	memcpy(tmp + 0xc0, pbuf + 0xb0, 0x10);
	memcpy(tmp + 0x70, test_k140, 0x10);
	memset(tmp, 0, 0x70);
	
	if (tkey->type == 6)
		memcpy(tmp + 0x50, ebuf + 0x40 + 0x40, 0x20);
	
	memcpy(tmp + 0x08, tag_key, 0x10);
	
	k4[0] = 0x014c;
	k4[1] = tkey->tag;

	kirk_CMD11(tmp, tmp, 0x150);

	memcpy(tmp + 0x5c, test_k140, 0x10);
	memcpy(tmp + 0x6c, tmp, 0x14);

	k4 = (u32*)(tmp + 0x48);
	k4[0] = KIRK_MODE_ENCRYPT_CBC;
	k4[1] = 0;
	k4[2] = 0;
	k4[3] = tkey->code;
	k4[4] = 0x60;
	kirk_CMD4(tmp + 0x48, tmp + 0x48, 0x60);

	memset(tmp, 0, 0x5c);
	
	if (tkey->type == 6)
		memcpy(tmp + 0x3c, ebuf + 0x40 + 0x40, 0x20);
	
	k4 = (u32*)tmp;
	k4[0] = tkey->tag;

	memcpy(ebuf + 0x000, tmp + 0xd0, 0x80);
	memcpy(ebuf + 0x080, tmp + 0x80, 0x30);
	memcpy(ebuf + 0x0b0, tmp + 0xc0, 0x10);
	memcpy(ebuf + 0x0c0, tmp + 0xb0, 0x10);
	memcpy(ebuf + 0x0d0, tmp + 0x00, 0x5c);
	memcpy(ebuf + 0x12c, tmp + 0x6c, 0x14);
	memcpy(ebuf + 0x140, tmp + 0x5c, 0x10);
}

/*
	PSP EBOOT signing function.
*/
int sign_eboot(u8 *eboot, int eboot_size, int tag, u8 *seboot)
{
	PSP_Header2 psp_header;
	
	// Select tag.
	tkey = &key_list[tag];

	// Allocate buffer for EBOOT data.
	int esize = eboot_size;
	u8 *ebuf = (u8 *) malloc(esize + 4096);
	memset(ebuf, 0, esize + 4096);

	// Read EBOOT data.
	memcpy(ebuf + 0x150, eboot, esize);
	
	if (*(u32*)(ebuf + 0x150) != 0x464C457F) {
		fprintf(stderr, "ERROR: Invalid ELF file for EBOOT resigning!\n");
		return -1;
	}
	
	// printf("Resigning EBOOT file with tag %08X\n", tkey->tag);

	// Build ~PSP header.
	build_psp_header(&psp_header, ebuf + 0x150, esize);
	
	// Encrypt and sign data with KIRK1.
	build_psp_kirk1(ebuf + 0x40, (u8*)&psp_header, esize);
	
	// Generate PRX tag key.
	build_tag_key(tkey);
	
	// Hash the data.
	build_psp_SHA1(ebuf, (u8*)&psp_header);

	// Copy back the generated EBOOT.
	esize = (esize + 15) &~ 15;
	memcpy(seboot, ebuf, esize + 0x150);
	
	return (esize + 0x150);
}